"""
Halmos Integration - Symbolic execution for formal verification.

Halmos is a symbolic execution tool for Solidity:
- Proves properties hold for ALL possible inputs
- Finds counterexamples when properties fail
- Integrates with Foundry test format

This integration:
1. Generates Halmos-compatible tests from invariants
2. Runs symbolic execution
3. Parses results for counterexamples
4. Converts to findings
"""

import asyncio
import subprocess
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

from rich.console import Console

from ..core.types import Finding, Severity, VulnerabilityType
from ..knowledge.invariants import Invariant, InvariantCategory

console = Console()


@dataclass
class HalmosResult:
    """Result from a Halmos verification run."""
    invariant_id: str
    property_name: str
    status: str  # "proved", "failed", "timeout", "error"
    counterexample: Optional[dict] = None
    time_seconds: float = 0.0
    error_message: str = ""


@dataclass
class HalmosConfig:
    """Configuration for Halmos runs."""
    timeout: int = 300  # 5 minutes per property
    solver: str = "z3"  # z3, yices, cvc5
    loop_bound: int = 10
    array_lengths: int = 3
    storage_layout: bool = True
    debug: bool = False


class HalmosTestGenerator:
    """
    Generate Halmos-compatible Foundry tests from invariants.

    Halmos tests use symbolic inputs (vm.assume, vm.expectRevert)
    to prove properties for all possible values.
    """

    TEST_TEMPLATE = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

{imports}

/// @title Halmos Symbolic Tests for {contract_name}
/// @notice Generated by SENTINEL - run with: halmos --contract {test_name}
contract {test_name} is Test {{
    {target_contract} target;

    function setUp() public {{
        {setup_code}
    }}

{test_functions}
}}
'''

    PROPERTY_TEMPLATE = '''
    /// @notice {description}
    /// @custom:halmos --solver {solver}
    function check_{id}({params}) public {{
        // Assume preconditions
        {assumptions}

        // Execute action
        {action}

        // Assert property
        {assertion}
    }}
'''

    def __init__(self, config: Optional[HalmosConfig] = None):
        self.config = config or HalmosConfig()

    def generate_test_file(
        self,
        invariants: list[Invariant],
        target_contract: str,
        imports: str = "",
        setup_code: str = "",
    ) -> str:
        """Generate complete Halmos test file."""
        test_functions = []

        for inv in invariants:
            test_func = self._generate_property_test(inv, target_contract)
            test_functions.append(test_func)

        return self.TEST_TEMPLATE.format(
            imports=imports,
            contract_name=target_contract,
            test_name=f"Halmos{target_contract}Test",
            target_contract=target_contract,
            setup_code=setup_code or f"target = new {target_contract}();",
            test_functions="\n".join(test_functions),
        )

    def _generate_property_test(self, inv: Invariant, target: str) -> str:
        """Generate a single property test."""
        # Determine symbolic parameters based on invariant
        params = self._infer_params(inv)

        # Generate assumptions (preconditions)
        assumptions = self._generate_assumptions(inv)

        # Generate action (if needed)
        action = self._generate_action(inv)

        # Generate assertion
        assertion = self._generate_assertion(inv)

        return self.PROPERTY_TEMPLATE.format(
            description=inv.description,
            solver=self.config.solver,
            id=inv.id.replace("-", "_").lower(),
            params=params,
            assumptions=assumptions,
            action=action,
            assertion=assertion,
        )

    def _infer_params(self, inv: Invariant) -> str:
        """Infer symbolic parameters from invariant."""
        params = []

        # Look for common variable patterns
        expr_lower = inv.expression.lower()

        if "amount" in expr_lower:
            params.append("uint256 amount")
        if "user" in expr_lower or "account" in expr_lower:
            params.append("address user")
        if "balance" in expr_lower:
            params.append("uint256 balance")
        if "token" in expr_lower:
            params.append("address token")

        # Default: add a generic value if no params detected
        if not params:
            params.append("uint256 value")

        return ", ".join(params)

    def _generate_assumptions(self, inv: Invariant) -> str:
        """Generate Halmos assumptions."""
        assumptions = []

        # Add common assumptions
        assumptions.append("vm.assume(amount > 0);")
        assumptions.append("vm.assume(amount < type(uint128).max);")

        if "user" in inv.expression.lower():
            assumptions.append("vm.assume(user != address(0));")

        return "\n        ".join(assumptions)

    def _generate_action(self, inv: Invariant) -> str:
        """Generate the action to test."""
        # For most invariants, we don't need an action
        # The assertion checks the invariant directly
        return "// No action needed - checking invariant directly"

    def _generate_assertion(self, inv: Invariant) -> str:
        """Generate assertion from invariant expression."""
        expr = inv.expression

        # Handle implication (A => B becomes assert(!A || B))
        if "=>" in expr:
            parts = expr.split("=>")
            if len(parts) == 2:
                return f"assertTrue(!({parts[0].strip()}) || ({parts[1].strip()}));"

        # Direct assertion
        return f"assertTrue({expr});"


class HalmosRunner:
    """
    Run Halmos symbolic execution and parse results.
    """

    def __init__(
        self,
        project_path: Path,
        config: Optional[HalmosConfig] = None,
    ):
        self.project_path = project_path
        self.config = config or HalmosConfig()
        self.results: list[HalmosResult] = []

    async def run_verification(
        self,
        test_contract: Optional[str] = None,
    ) -> list[HalmosResult]:
        """Run Halmos verification."""
        cmd = [
            "halmos",
            "--root", str(self.project_path),
            "--solver", self.config.solver,
            "--loop", str(self.config.loop_bound),
            "--array-lengths", str(self.config.array_lengths),
        ]

        if test_contract:
            cmd.extend(["--contract", test_contract])

        if self.config.storage_layout:
            cmd.append("--storage-layout")

        if self.config.debug:
            cmd.append("--debug")

        console.print(f"[cyan]Running Halmos: {' '.join(cmd)}[/cyan]")

        try:
            result = subprocess.run(
                cmd,
                cwd=self.project_path,
                capture_output=True,
                text=True,
                timeout=self.config.timeout,
            )

            # Parse output
            results = self._parse_output(result.stdout + result.stderr)
            self.results.extend(results)

            # Summary
            proved = sum(1 for r in results if r.status == "proved")
            failed = sum(1 for r in results if r.status == "failed")

            console.print(f"[green]Proved: {proved}[/green] | [red]Failed: {failed}[/red]")

            return results

        except subprocess.TimeoutExpired:
            console.print(f"[yellow]Halmos timed out after {self.config.timeout}s[/yellow]")
            return []
        except FileNotFoundError:
            console.print("[red]Halmos not installed. Run: pip install halmos[/red]")
            return []

    def _parse_output(self, output: str) -> list[HalmosResult]:
        """Parse Halmos output for results."""
        results = []

        # Pattern for test results
        # Example: [PASS] check_balance_invariant
        # Example: [FAIL] check_access_control (counterexample: ...)
        pass_pattern = r'\[PASS\]\s+(\w+)'
        fail_pattern = r'\[FAIL\]\s+(\w+)(?:\s*\(counterexample:\s*([^)]+)\))?'
        timeout_pattern = r'\[TIMEOUT\]\s+(\w+)'

        for match in re.finditer(pass_pattern, output):
            results.append(HalmosResult(
                invariant_id=match.group(1),
                property_name=match.group(1),
                status="proved",
            ))

        for match in re.finditer(fail_pattern, output):
            counterexample = None
            if match.group(2):
                # Parse counterexample values
                counterexample = {"raw": match.group(2)}

            results.append(HalmosResult(
                invariant_id=match.group(1),
                property_name=match.group(1),
                status="failed",
                counterexample=counterexample,
            ))

        for match in re.finditer(timeout_pattern, output):
            results.append(HalmosResult(
                invariant_id=match.group(1),
                property_name=match.group(1),
                status="timeout",
            ))

        return results

    def results_to_findings(self, contract_name: str) -> list[Finding]:
        """Convert failed verification results to findings."""
        findings = []

        for result in self.results:
            if result.status != "failed":
                continue

            # Counterexample info
            counterexample_info = ""
            if result.counterexample:
                counterexample_info = f"\n\n**Counterexample:**\n```\n{result.counterexample.get('raw', 'N/A')}\n```"

            findings.append(Finding(
                id=f"{contract_name}-HALMOS-{result.invariant_id}",
                title=f"Formal Verification Failed: {result.property_name}",
                severity=Severity.HIGH,  # Formal verification failures are serious
                vulnerability_type=VulnerabilityType.BUSINESS_LOGIC,
                description=f"""**Property Failed:** `{result.property_name}`

Halmos symbolic execution found a counterexample that violates this property.
This means there exists at least one input that breaks the invariant.
{counterexample_info}

**What This Means:**
The property does NOT hold for all possible inputs. An attacker may be able
to exploit this to cause unexpected behavior.

**Next Steps:**
1. Analyze the counterexample to understand the attack
2. Verify the counterexample manually
3. Fix the vulnerability or strengthen the property""",
                contract=contract_name,
                confidence=0.95,  # Formal verification is high confidence
                references=["Halmos symbolic execution"],
            ))

        return findings


class HalmosIntegration:
    """
    High-level integration for Halmos verification.
    """

    def __init__(
        self,
        project_path: Path,
        config: Optional[HalmosConfig] = None,
    ):
        self.project_path = project_path
        self.config = config or HalmosConfig()
        self.generator = HalmosTestGenerator(config)
        self.runner = HalmosRunner(project_path, config)

    async def verify_invariants(
        self,
        invariants: list[Invariant],
        target_contract: str,
        imports: str = "",
        setup_code: str = "",
    ) -> list[Finding]:
        """Generate tests, run Halmos, and return findings."""
        # Generate test file
        test_content = self.generator.generate_test_file(
            invariants,
            target_contract,
            imports,
            setup_code,
        )

        # Write test file
        test_path = self.project_path / "test" / "halmos" / f"{target_contract}.halmos.t.sol"
        test_path.parent.mkdir(parents=True, exist_ok=True)
        test_path.write_text(test_content)

        console.print(f"[green]Generated Halmos test: {test_path}[/green]")

        # Run verification
        results = await self.runner.run_verification(
            test_contract=f"Halmos{target_contract}Test"
        )

        # Convert to findings
        findings = self.runner.results_to_findings(target_contract)

        return findings


# Convenience function
async def verify_with_halmos(
    invariants: list[Invariant],
    project_path: Path,
    target_contract: str,
) -> list[Finding]:
    """Quick verification with Halmos."""
    integration = HalmosIntegration(project_path)
    return await integration.verify_invariants(invariants, target_contract)
