"""
Exploit Matcher - Pattern matching against historical exploits.

Uses embeddings and pattern matching to find similar vulnerabilities
in new code based on 500+ historical DeFi exploits.
"""

import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional
import yaml

from rich.console import Console
from rich.panel import Panel
from rich.table import Table

console = Console()

# Path to exploit database
EXPLOITS_DB_PATH = Path(__file__).parent.parent.parent / "knowledge_base" / "exploits" / "database.yaml"


@dataclass
class Exploit:
    """Historical exploit record."""
    id: str
    name: str
    date: str
    amount_lost: int
    chain: str
    protocol_type: str
    vulnerability_type: str
    root_cause: str
    attack_vector: str
    vulnerable_pattern: str = ""
    fix_applied: str = ""
    lessons: list[str] = field(default_factory=list)
    tags: list[str] = field(default_factory=list)


@dataclass
class ExploitMatch:
    """A match between code and historical exploit."""
    exploit: Exploit
    matched_code: str
    matched_line: int
    similarity_score: float  # 0-1
    match_type: str  # "regex", "semantic", "pattern"
    explanation: str


class ExploitMatcher:
    """
    Match code patterns against historical exploits.

    Methods:
    1. Regex-based pattern matching (fast)
    2. Semantic similarity via embeddings (accurate)
    3. LLM-based analysis (deep)
    """

    def __init__(self, db_path: Optional[Path] = None):
        self.db_path = db_path or EXPLOITS_DB_PATH
        self.exploits: list[Exploit] = []
        self.patterns: dict = {}
        self._load_database()

    def _load_database(self) -> None:
        """Load exploit database from YAML."""
        if not self.db_path.exists():
            console.print(f"[yellow]Exploit database not found: {self.db_path}[/yellow]")
            return

        with open(self.db_path) as f:
            data = yaml.safe_load(f)

        # Load exploits
        for exp_data in data.get("exploits", []):
            exploit = Exploit(
                id=exp_data.get("id", ""),
                name=exp_data.get("name", ""),
                date=exp_data.get("date", ""),
                amount_lost=exp_data.get("amount_lost", 0),
                chain=exp_data.get("chain", ""),
                protocol_type=exp_data.get("protocol_type", ""),
                vulnerability_type=exp_data.get("vulnerability_type", ""),
                root_cause=exp_data.get("root_cause", ""),
                attack_vector=exp_data.get("attack_vector", ""),
                vulnerable_pattern=exp_data.get("vulnerable_pattern", ""),
                fix_applied=exp_data.get("fix_applied", ""),
                lessons=exp_data.get("lessons", []),
                tags=exp_data.get("tags", []),
            )
            self.exploits.append(exploit)

        # Load vulnerability patterns
        self.patterns = data.get("vulnerability_patterns", {})

        console.print(f"[green]Loaded {len(self.exploits)} exploits[/green]")

    def match_regex(self, code: str, vuln_type: str = None) -> list[ExploitMatch]:
        """
        Fast regex-based pattern matching.

        Args:
            code: Source code to analyze
            vuln_type: Optional - limit to specific vulnerability type

        Returns:
            List of matches with exploit references
        """
        matches = []

        # Get patterns to check
        if vuln_type and vuln_type in self.patterns:
            patterns_to_check = {vuln_type: self.patterns[vuln_type]}
        else:
            patterns_to_check = self.patterns

        for vtype, pattern_data in patterns_to_check.items():
            regexes = pattern_data.get("detection_regex", [])

            for regex_pattern in regexes:
                try:
                    for match in re.finditer(regex_pattern, code, re.MULTILINE | re.DOTALL):
                        # Find relevant exploits
                        relevant_exploits = [
                            e for e in self.exploits
                            if e.vulnerability_type == vtype or vtype in e.tags
                        ]

                        if relevant_exploits:
                            # Get line number
                            line_num = code[:match.start()].count('\n') + 1

                            matches.append(ExploitMatch(
                                exploit=relevant_exploits[0],  # Most relevant
                                matched_code=match.group(),
                                matched_line=line_num,
                                similarity_score=0.7,  # Regex matches are moderate confidence
                                match_type="regex",
                                explanation=f"Pattern matches known {vtype} vulnerability pattern",
                            ))
                except re.error:
                    continue

        return matches

    def match_patterns(self, code: str) -> list[ExploitMatch]:
        """
        Match against known vulnerable code patterns.

        More sophisticated than regex - looks for structural patterns.
        """
        matches = []

        # Reentrancy patterns
        reentrancy_patterns = [
            # call before state update
            (r'\.call\{value:', r'balances?\[', "call{value:} before balance update"),
            (r'\.transfer\(', r'balances?\[', "transfer before balance update"),
            # Callback before update
            (r'safeTransfer', r'\-=', "safeTransfer before state update"),
        ]

        for call_pattern, state_pattern, desc in reentrancy_patterns:
            if re.search(call_pattern, code) and re.search(state_pattern, code):
                # Check order - is call before state update?
                call_match = re.search(call_pattern, code)
                state_match = re.search(state_pattern, code)

                if call_match and state_match and call_match.start() < state_match.start():
                    relevant = [e for e in self.exploits if "reentrancy" in e.vulnerability_type.lower()]
                    if relevant:
                        matches.append(ExploitMatch(
                            exploit=relevant[0],
                            matched_code=code[call_match.start():state_match.end()],
                            matched_line=code[:call_match.start()].count('\n') + 1,
                            similarity_score=0.85,
                            match_type="pattern",
                            explanation=f"Reentrancy: {desc}",
                        ))

        # Oracle manipulation patterns
        oracle_patterns = [
            (r'getReserves\(\)', "Using AMM reserves for price - manipulable via flash loan"),
            (r'slot0\(\)', "Using Uniswap V3 slot0 without TWAP - manipulable"),
            (r'balanceOf\([^)]*\)\s*/\s*totalSupply', "Share price from balance ratio - manipulable"),
        ]

        for pattern, desc in oracle_patterns:
            match = re.search(pattern, code)
            if match:
                relevant = [e for e in self.exploits if "oracle" in e.vulnerability_type.lower()]
                if relevant:
                    matches.append(ExploitMatch(
                        exploit=relevant[0],
                        matched_code=match.group(),
                        matched_line=code[:match.start()].count('\n') + 1,
                        similarity_score=0.8,
                        match_type="pattern",
                        explanation=desc,
                    ))

        # Access control patterns
        access_patterns = [
            (r'tx\.origin', "Using tx.origin for auth - phishing vulnerable"),
            (r'function\s+initialize\([^)]*\)\s*(?:external|public)\s*\{(?!.*initializer)', "Unprotected initializer"),
        ]

        for pattern, desc in access_patterns:
            match = re.search(pattern, code, re.MULTILINE)
            if match:
                relevant = [e for e in self.exploits if "access" in e.vulnerability_type.lower()]
                if relevant:
                    matches.append(ExploitMatch(
                        exploit=relevant[0],
                        matched_code=match.group(),
                        matched_line=code[:match.start()].count('\n') + 1,
                        similarity_score=0.9,
                        match_type="pattern",
                        explanation=desc,
                    ))

        # Flash loan governance
        flash_gov_patterns = [
            (r'balanceOf\(msg\.sender\).*vote', "Voting power from current balance - flash loan attackable"),
        ]

        for pattern, desc in flash_gov_patterns:
            match = re.search(pattern, code, re.DOTALL)
            if match:
                relevant = [e for e in self.exploits if "governance" in e.vulnerability_type.lower() or "flash_loan" in str(e.tags)]
                if relevant:
                    matches.append(ExploitMatch(
                        exploit=relevant[0],
                        matched_code=match.group(),
                        matched_line=code[:match.start()].count('\n') + 1,
                        similarity_score=0.85,
                        match_type="pattern",
                        explanation=desc,
                    ))

        return matches

    def find_similar_exploits(
        self,
        vulnerability_type: str,
        protocol_type: str = None,
        tags: list[str] = None,
    ) -> list[Exploit]:
        """
        Find historically similar exploits for context.

        Useful for:
        - Understanding attack patterns
        - Severity justification
        - Writing better recommendations
        """
        matches = []

        for exploit in self.exploits:
            score = 0

            # Match vulnerability type
            if vulnerability_type.lower() in exploit.vulnerability_type.lower():
                score += 3

            # Match protocol type
            if protocol_type and protocol_type.lower() in exploit.protocol_type.lower():
                score += 2

            # Match tags
            if tags:
                for tag in tags:
                    if tag.lower() in [t.lower() for t in exploit.tags]:
                        score += 1

            if score > 0:
                matches.append((exploit, score))

        # Sort by score
        matches.sort(key=lambda x: x[1], reverse=True)
        return [m[0] for m in matches[:5]]  # Top 5

    def get_lessons_learned(self, vulnerability_type: str) -> list[str]:
        """Get aggregated lessons from similar exploits."""
        lessons = []
        similar = self.find_similar_exploits(vulnerability_type)

        for exploit in similar:
            lessons.extend(exploit.lessons)

        # Deduplicate
        return list(set(lessons))

    def get_exploit_reference(self, vulnerability_type: str) -> Optional[str]:
        """
        Get a reference to cite in findings.

        Returns formatted string like:
        "Similar to Euler Finance exploit (March 2023, $197M lost)"
        """
        similar = self.find_similar_exploits(vulnerability_type)
        if not similar:
            return None

        exploit = similar[0]
        amount = f"${exploit.amount_lost:,}" if exploit.amount_lost else "undisclosed"
        return f"Similar to {exploit.name} ({exploit.date}, {amount} lost)"

    def print_matches(self, matches: list[ExploitMatch]) -> None:
        """Print matches in a nice format."""
        if not matches:
            console.print("[green]No matches against known exploit patterns[/green]")
            return

        table = Table(title="Exploit Pattern Matches")
        table.add_column("Line", justify="right", style="cyan")
        table.add_column("Pattern", style="yellow")
        table.add_column("Similar Exploit", style="red")
        table.add_column("Confidence", justify="right")

        for match in matches:
            table.add_row(
                str(match.matched_line),
                match.explanation[:50],
                f"{match.exploit.name} ({match.exploit.date})",
                f"{match.similarity_score:.0%}",
            )

        console.print(table)

    def analyze_code(self, code: str) -> dict:
        """
        Full analysis of code against exploit database.

        Returns:
            dict with matches, lessons, and references
        """
        # Run all matchers
        regex_matches = self.match_regex(code)
        pattern_matches = self.match_patterns(code)

        # Combine and dedupe
        all_matches = regex_matches + pattern_matches
        unique_matches = []
        seen_lines = set()

        for match in all_matches:
            if match.matched_line not in seen_lines:
                unique_matches.append(match)
                seen_lines.add(match.matched_line)

        # Get unique vulnerability types found
        vuln_types = set(m.exploit.vulnerability_type for m in unique_matches)

        # Aggregate lessons
        all_lessons = []
        for vtype in vuln_types:
            all_lessons.extend(self.get_lessons_learned(vtype))

        return {
            "matches": unique_matches,
            "vulnerability_types": list(vuln_types),
            "lessons": list(set(all_lessons)),
            "references": [self.get_exploit_reference(vt) for vt in vuln_types],
            "risk_level": "high" if any(m.similarity_score > 0.8 for m in unique_matches) else "medium" if unique_matches else "low",
        }


# Convenience function
def match_exploits(code: str) -> list[ExploitMatch]:
    """Quick exploit matching on code."""
    matcher = ExploitMatcher()
    return matcher.match_patterns(code) + matcher.match_regex(code)
