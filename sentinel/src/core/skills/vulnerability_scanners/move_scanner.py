"""
Move Vulnerability Scanner - Based on Move Vulnerability Database (MVD v2.0)

Scans Move smart contracts (Aptos/Sui) for vulnerability patterns derived from
501 findings across 150+ public audit reports.

Top vulnerability categories (by frequency):
1. Business Logic (137) - Flawed protocol design/rules
2. Calculation Errors (87) - Arithmetic precision, overflow
3. Input Validation (59) - Missing parameter checks
4. Access Control (41) - Missing authorization
5. State Management (37) - Incorrect state transitions
6. Denial of Service (27) - Resource exhaustion, unbounded ops
7. Oracle Issues (19) - Price manipulation, stale data
8. Data Inconsistency (17) - Mismatched state across modules

Sources:
- https://github.com/MoveMaverick/move-vulnerability-database
- https://movemaverick.github.io/move-vulnerability-database/
- https://github.com/0xriazaka/Move-Audit-Resources
"""

from pathlib import Path
import re
from .base_scanner import PlatformScanner, PlatformVulnerability, ScanReport, VulnerabilitySeverity


class MoveVulnerabilityScanner(PlatformScanner):
    """Scan Move (Aptos/Sui) contracts for platform-specific vulnerabilities."""

    PATTERNS = [
        {
            "id": "MOVE-001",
            "name": "Unchecked Arithmetic",
            "severity": VulnerabilitySeverity.HIGH,
            "pattern": r"\b(mul|div|add|sub)\s*\(|[\+\-\*\/]\s*\w+",
            "context_pattern": r"(balance|amount|supply|price|rate|fee|reward)",
            "description": "Arithmetic without overflow/underflow protection",
            "attack": "Overflow/underflow in financial calculations leads to fund loss",
            "fix": "Use checked math functions, validate ranges before operations",
        },
        {
            "id": "MOVE-002",
            "name": "Missing Access Control",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"public(\s+entry)?\s+fun\s+\w+",
            "negative_pattern": r"(assert!.*signer|assert!.*owner|assert!.*admin|&signer)",
            "description": "Public function without signer/authority validation",
            "attack": "Unauthorized users call privileged functions",
            "fix": "Add signer validation with assert! checks on caller identity",
        },
        {
            "id": "MOVE-003",
            "name": "Missing Input Validation",
            "severity": VulnerabilitySeverity.HIGH,
            "pattern": r"public(\s+entry)?\s+fun\s+\w+\s*\([^)]*u64[^)]*\)",
            "negative_pattern": r"assert!\s*\(\s*\w+\s*[><=!]",
            "description": "Numeric parameters accepted without bounds checking",
            "attack": "Extreme values cause unexpected behavior or economic exploits",
            "fix": "Validate all numeric inputs against expected ranges",
        },
        {
            "id": "MOVE-004",
            "name": "Unsafe Coin Operations",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"coin::extract|coin::merge|coin::destroy_zero",
            "negative_pattern": r"(assert!.*value|coin::value)",
            "description": "Coin operations without value verification",
            "attack": "Token value manipulation through unchecked coin operations",
            "fix": "Always verify coin values before extract/merge/destroy",
        },
        {
            "id": "MOVE-005",
            "name": "Missing Capability Check",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"move_to|borrow_global_mut|move_from",
            "negative_pattern": r"(assert!.*exists|assert!.*signer::address_of|acquires)",
            "description": "Global storage operations without proper capability checks",
            "attack": "Unauthorized global storage modification",
            "fix": "Validate capabilities and resource existence before storage ops",
        },
        {
            "id": "MOVE-006",
            "name": "Unbounded Iteration",
            "severity": VulnerabilitySeverity.MEDIUM,
            "pattern": r"while\s*\(|vector::for_each|vector::length",
            "context_pattern": r"(vector|table|simple_map)",
            "description": "Unbounded loop over dynamic collection may cause gas exhaustion",
            "attack": "Attacker grows collection to cause DoS via gas exhaustion",
            "fix": "Cap iteration with maximum bounds, use pagination patterns",
        },
        {
            "id": "MOVE-007",
            "name": "Timestamp Dependence",
            "severity": VulnerabilitySeverity.MEDIUM,
            "pattern": r"timestamp::now_seconds|timestamp::now_microseconds",
            "context_pattern": r"(deadline|expir|lock|unlock|vest|cliff)",
            "description": "Time-sensitive logic depends on block timestamp",
            "attack": "Validators can manipulate timestamps within bounds",
            "fix": "Use timestamp only for coarse-grained time checks",
        },
        {
            "id": "MOVE-008",
            "name": "Missing Event Emission",
            "severity": VulnerabilitySeverity.LOW,
            "pattern": r"public(\s+entry)?\s+fun\s+\w+[^}]+move_to|borrow_global_mut",
            "negative_pattern": r"event::emit",
            "description": "State-changing function without event emission",
            "attack": "Missing audit trail makes monitoring and incident response difficult",
            "fix": "Emit events for all state-changing operations",
        },
        {
            "id": "MOVE-009",
            "name": "Oracle Price Manipulation",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"(get_price|price_feed|oracle)",
            "negative_pattern": r"(staleness|freshness|deviation|heartbeat|assert!.*timestamp)",
            "description": "Oracle price used without freshness/deviation checks",
            "attack": "Stale or manipulated prices lead to incorrect valuations",
            "fix": "Validate oracle freshness, add deviation bounds, use TWAP",
        },
        {
            "id": "MOVE-010",
            "name": "Flash Loan Vulnerability",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"(flash_loan|borrow_flash|flash_borrow)",
            "negative_pattern": r"(assert!.*repay|assert!.*balance.*>=)",
            "description": "Flash loan without proper repayment enforcement",
            "attack": "Borrower manipulates state during flash loan without repaying",
            "fix": "Enforce repayment with hot potato pattern or balance checks",
        },
    ]

    def __init__(self, project_path: str):
        super().__init__(project_path, "move")

    def scan(self) -> ScanReport:
        """Scan Move contracts for vulnerabilities."""
        vulnerabilities = []
        files_scanned = []

        for move_file in self.project_path.glob("**/*.move"):
            content = move_file.read_text()
            rel_path = str(move_file.relative_to(self.project_path))
            files_scanned.append(rel_path)

            # Detect ecosystem (Aptos vs Sui)
            is_aptos = "aptos_framework" in content or "aptos_std" in content
            is_sui = "sui::object" in content or "sui::transfer" in content

            for pattern_def in self.PATTERNS:
                for match in re.finditer(pattern_def["pattern"], content, re.IGNORECASE):
                    # Context check
                    if "context_pattern" in pattern_def:
                        context = content[max(0, match.start() - 200):match.end() + 200]
                        if not re.search(pattern_def["context_pattern"], context, re.IGNORECASE):
                            continue

                    # Protection check
                    has_protection = False
                    if "negative_pattern" in pattern_def:
                        func_context = content[max(0, match.start() - 1000):match.end() + 1000]
                        if re.search(pattern_def["negative_pattern"], func_context, re.IGNORECASE):
                            has_protection = True

                    if not has_protection:
                        line_num = content[:match.start()].count("\n") + 1
                        vulnerabilities.append(PlatformVulnerability(
                            pattern_id=pattern_def["id"],
                            name=pattern_def["name"],
                            severity=pattern_def["severity"],
                            file_path=rel_path,
                            line_number=line_num,
                            code_snippet=self._get_context(content, match.start()),
                            description=pattern_def["description"],
                            attack_scenario=pattern_def["attack"],
                            recommendation=pattern_def["fix"],
                        ))

        return ScanReport(
            platform="move",
            project_path=str(self.project_path),
            files_scanned=files_scanned,
            vulnerabilities=vulnerabilities,
        )


def scan_move(project_path: str, output_path: str = None) -> ScanReport:
    """Scan Move project for vulnerabilities."""
    scanner = MoveVulnerabilityScanner(project_path)
    report = scanner.scan()
    if output_path:
        Path(output_path).write_text(report.to_markdown())
    return report
