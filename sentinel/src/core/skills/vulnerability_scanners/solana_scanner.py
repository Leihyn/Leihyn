"""
Solana Vulnerability Scanner - Trail of Bits Skill

Scans Solana programs for 6 critical vulnerability patterns:
1. Arbitrary CPI (user-controlled program IDs)
2. Improper PDA Validation (non-canonical bumps)
3. Missing Ownership Check (unvalidated account owners)
4. Missing Signer Check (unsigned authority operations)
5. Sysvar Account Spoofing (pre-1.8.1)
6. Improper Instruction Introspection

Based on: https://github.com/trailofbits/skills/tree/main/plugins/building-secure-contracts
"""

from pathlib import Path
import re
from .base_scanner import PlatformScanner, PlatformVulnerability, ScanReport, VulnerabilitySeverity


class SolanaVulnerabilityScanner(PlatformScanner):
    """Scan Solana/Anchor programs for platform-specific vulnerabilities."""

    PATTERNS = [
        {
            "id": "SOL-001",
            "name": "Arbitrary CPI",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"invoke\s*\(|invoke_signed\s*\(",
            "negative_pattern": r"Program<'info",  # Anchor type-safe pattern
            "description": "Cross-Program Invocation without program ID validation",
            "attack": "Attacker provides malicious program that impersonates legitimate CPI target",
            "fix": "Use Anchor's Program<'info, T> type or validate program key before invoke()",
        },
        {
            "id": "SOL-002",
            "name": "Improper PDA Validation",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"create_program_address\s*\(",
            "negative_pattern": r"find_program_address",
            "description": "Using create_program_address without canonical bump verification",
            "attack": "Attacker provides non-canonical bump to derive different address",
            "fix": "Use find_program_address() or Anchor seeds constraint with canonical bump",
        },
        {
            "id": "SOL-003",
            "name": "Missing Ownership Check",
            "severity": VulnerabilitySeverity.HIGH,
            "pattern": r"try_from_slice|try_deserialize|AccountDeserialize",
            "negative_pattern": r"\.owner\s*==|Account<'info",
            "description": "Account deserialized without owner validation",
            "attack": "Attacker creates fake account with malicious data, passes it as trusted",
            "fix": "Validate account.owner before deserialization, use Anchor Account<'info, T>",
        },
        {
            "id": "SOL-004",
            "name": "Missing Signer Check",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"authority|admin|owner|governance",
            "negative_pattern": r"is_signer|Signer<'info",
            "description": "Authority operation without signer verification",
            "attack": "Anyone can call privileged functions without proving authority",
            "fix": "Check account.is_signer or use Anchor Signer<'info> type",
        },
        {
            "id": "SOL-005",
            "name": "Sysvar Account Spoofing",
            "severity": VulnerabilitySeverity.HIGH,
            "pattern": r"load_instruction_at\b|sysvar",
            "negative_pattern": r"load_instruction_at_checked|Sysvar<'info",
            "description": "Sysvar account not validated (pre-Solana 1.8.1 vulnerability)",
            "attack": "Attacker spoofs sysvar account to bypass security checks",
            "fix": "Use checked functions: load_instruction_at_checked() (Solana 1.8.1+)",
        },
        {
            "id": "SOL-006",
            "name": "Improper Instruction Introspection",
            "severity": VulnerabilitySeverity.MEDIUM,
            "pattern": r"load_instruction_at|get_instruction_relative",
            "negative_pattern": r"load_current_index_checked",
            "description": "Absolute instruction indexes allowing reuse across calls",
            "attack": "Attacker reuses same instruction across multiple calls",
            "fix": "Use relative indexing and checked functions for instruction introspection",
        },
    ]

    def __init__(self, project_path: str):
        super().__init__(project_path, "solana")

    def scan(self) -> ScanReport:
        """Scan Solana programs for vulnerabilities."""
        vulnerabilities = []
        files_scanned = []

        # Find Rust files with Solana indicators
        for rs_file in self.project_path.glob("**/*.rs"):
            content = rs_file.read_text()

            # Check if this is a Solana program
            if not ("solana_program" in content or "anchor_lang" in content):
                continue

            rel_path = str(rs_file.relative_to(self.project_path))
            files_scanned.append(rel_path)

            is_anchor = "anchor_lang" in content

            for pattern_def in self.PATTERNS:
                # Search for vulnerable pattern
                for match in re.finditer(pattern_def["pattern"], content, re.IGNORECASE):
                    # Check if protection is in place
                    context = content[max(0, match.start()-500):match.end()+500]

                    has_protection = False
                    if pattern_def.get("negative_pattern"):
                        if re.search(pattern_def["negative_pattern"], context, re.IGNORECASE):
                            has_protection = True

                    # Anchor provides many protections automatically
                    if is_anchor and pattern_def["id"] in ["SOL-003", "SOL-004"]:
                        has_protection = True

                    if not has_protection:
                        line_num = content[:match.start()].count('\n') + 1
                        vulnerabilities.append(PlatformVulnerability(
                            pattern_id=pattern_def["id"],
                            name=pattern_def["name"],
                            severity=pattern_def["severity"],
                            file_path=rel_path,
                            line_number=line_num,
                            code_snippet=self._get_context(content, match.start()),
                            description=pattern_def["description"],
                            attack_scenario=pattern_def["attack"],
                            recommendation=pattern_def["fix"],
                        ))

        return ScanReport(
            platform="solana",
            project_path=str(self.project_path),
            files_scanned=files_scanned,
            vulnerabilities=vulnerabilities,
        )


def scan_solana(project_path: str, output_path: str = None) -> ScanReport:
    """Scan Solana project for vulnerabilities."""
    scanner = SolanaVulnerabilityScanner(project_path)
    report = scanner.scan()
    if output_path:
        Path(output_path).write_text(report.to_markdown())
    return report
