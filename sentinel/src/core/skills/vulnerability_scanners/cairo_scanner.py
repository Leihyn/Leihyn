"""
Cairo/StarkNet Vulnerability Scanner - Trail of Bits Skill

Scans Cairo contracts for 6 critical vulnerability patterns:
1. Unchecked Arithmetic (felt252 overflow/underflow)
2. Storage Collision (conflicting storage hashes)
3. Missing Access Control (no caller validation)
4. Improper Felt252 Boundaries (range validation)
5. Unvalidated Contract Address (untrusted addresses)
6. Unchecked L1 Handler (from_address validation)

Based on: https://github.com/trailofbits/skills/tree/main/plugins/building-secure-contracts
"""

from pathlib import Path
import re
from .base_scanner import PlatformScanner, PlatformVulnerability, ScanReport, VulnerabilitySeverity


class CairoVulnerabilityScanner(PlatformScanner):
    """Scan Cairo/StarkNet contracts for platform-specific vulnerabilities."""

    PATTERNS = [
        {
            "id": "CAIRO-001",
            "name": "Unchecked Arithmetic (felt252)",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"felt252.*[\+\-\*]|[\+\-\*].*felt252",
            "context_pattern": r"balance|amount|total|supply",
            "description": "Arithmetic on felt252 without overflow protection",
            "attack": "Attacker overflows felt252 arithmetic to manipulate balances",
            "fix": "Use u128/u256 for balances/amounts, or add explicit bounds checking",
        },
        {
            "id": "CAIRO-002",
            "name": "Storage Collision",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"LegacyMap.*LegacyMap|Map.*Map",
            "description": "Potential storage slot collision between mappings",
            "attack": "Storage slots overlap, causing data corruption",
            "fix": "Use unique storage variable names, verify with Caracal",
        },
        {
            "id": "CAIRO-003",
            "name": "Missing Access Control",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"#\[external\(v0\)\]|fn\s+\w+.*ref\s+self:\s*ContractState",
            "negative_pattern": r"get_caller_address|assert_only_owner|assert_caller",
            "description": "External function without caller validation",
            "attack": "Anyone can call privileged functions",
            "fix": "Add get_caller_address() check and validate against authorized address",
        },
        {
            "id": "CAIRO-004",
            "name": "Improper Felt252 Boundaries",
            "severity": VulnerabilitySeverity.HIGH,
            "pattern": r"felt252\s+\w+",
            "context_pattern": r"address|from_address|to_address",
            "description": "felt252 value not validated against proper range",
            "attack": "Values outside expected range cause unexpected behavior",
            "fix": "Validate felt252 values against expected boundaries",
        },
        {
            "id": "CAIRO-005",
            "name": "Unvalidated Contract Address",
            "severity": VulnerabilitySeverity.HIGH,
            "pattern": r"ContractAddress.*\w+\s*,",
            "negative_pattern": r"assert.*!=.*zero|contract_address_const",
            "description": "Contract address used without validation",
            "attack": "Attacker provides zero or malicious contract address",
            "fix": "Validate contract addresses are non-zero and authorized",
        },
        {
            "id": "CAIRO-006",
            "name": "Unchecked L1 Handler",
            "severity": VulnerabilitySeverity.CRITICAL,
            "pattern": r"#\[l1_handler\]",
            "negative_pattern": r"assert.*from_address|l1_bridge_address",
            "description": "L1 handler doesn't validate from_address parameter",
            "attack": "Any L1 contract can send messages, bypassing intended access control",
            "fix": "Validate from_address against stored L1 bridge address",
        },
    ]

    def __init__(self, project_path: str):
        super().__init__(project_path, "cairo")

    def scan(self) -> ScanReport:
        """Scan Cairo contracts for vulnerabilities."""
        vulnerabilities = []
        files_scanned = []

        for cairo_file in self.project_path.glob("**/*.cairo"):
            content = cairo_file.read_text()
            rel_path = str(cairo_file.relative_to(self.project_path))
            files_scanned.append(rel_path)

            for pattern_def in self.PATTERNS:
                for match in re.finditer(pattern_def["pattern"], content, re.IGNORECASE):
                    # Check context if required
                    if "context_pattern" in pattern_def:
                        context = content[max(0, match.start()-200):match.end()+200]
                        if not re.search(pattern_def["context_pattern"], context, re.IGNORECASE):
                            continue

                    # Check for protection
                    has_protection = False
                    if "negative_pattern" in pattern_def:
                        # Check in surrounding function context
                        func_context = content[max(0, match.start()-1000):match.end()+1000]
                        if re.search(pattern_def["negative_pattern"], func_context, re.IGNORECASE):
                            has_protection = True

                    if not has_protection:
                        line_num = content[:match.start()].count('\n') + 1
                        vulnerabilities.append(PlatformVulnerability(
                            pattern_id=pattern_def["id"],
                            name=pattern_def["name"],
                            severity=pattern_def["severity"],
                            file_path=rel_path,
                            line_number=line_num,
                            code_snippet=self._get_context(content, match.start()),
                            description=pattern_def["description"],
                            attack_scenario=pattern_def["attack"],
                            recommendation=pattern_def["fix"],
                        ))

        return ScanReport(
            platform="cairo",
            project_path=str(self.project_path),
            files_scanned=files_scanned,
            vulnerabilities=vulnerabilities,
        )


def scan_cairo(project_path: str, output_path: str = None) -> ScanReport:
    """Scan Cairo project for vulnerabilities."""
    scanner = CairoVulnerabilityScanner(project_path)
    report = scanner.scan()
    if output_path:
        Path(output_path).write_text(report.to_markdown())
    return report
