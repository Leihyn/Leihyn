# Extended Exploit Database - Part 2
# More exploits for comprehensive pattern matching

exploits_2024:
  - id: "2024-004"
    name: "Abracadabra MIM"
    date: "2024-01-30"
    amount_lost: 6500000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "rounding_error"
    root_cause: "Rounding error in borrow calculation allowed stealing funds"
    attack_vector: |
      1. Exploit rounding in elastic/base share conversion
      2. Borrow slightly more than collateral allows
      3. Repeat to amplify
    vulnerable_pattern: |
      function toBase(uint256 elastic) public view returns (uint256 base) {
          base = elastic * totalBase / totalElastic;  // Rounding down
      }
    lessons:
      - "Always round against the user/in protocol's favor"
      - "Check rounding at 0, 1, and max values"
    tags: ["lending", "rounding", "precision"]

  - id: "2024-005"
    name: "Gamma Strategies"
    date: "2024-01-04"
    amount_lost: 6300000
    chain: "arbitrum"
    protocol_type: "vault"
    vulnerability_type: "price_manipulation"
    root_cause: "Price change threshold check could be bypassed"
    attack_vector: |
      1. Manipulate price to just below threshold
      2. Deposit at manipulated price
      3. Restore price, withdraw at profit
    lessons:
      - "Thresholds can be gamed to stay just below"
      - "Use TWAP not spot for any price-sensitive logic"
    tags: ["vault", "oracle", "threshold"]

  - id: "2024-006"
    name: "Radiant Capital"
    date: "2024-01-02"
    amount_lost: 4500000
    chain: "arbitrum"
    protocol_type: "lending"
    vulnerability_type: "flash_loan"
    root_cause: "New market could be manipulated before liquidity"
    attack_vector: |
      1. Flash loan to be first LP in new market
      2. Manipulate empty market price
      3. Borrow against inflated collateral
    lessons:
      - "New markets need bootstrap liquidity"
      - "First depositor attacks"
    tags: ["lending", "flash_loan", "new_market", "first_depositor"]

exploits_2023_extended:
  - id: "2023-005"
    name: "Yearn yDAI"
    date: "2023-04-13"
    amount_lost: 11600000
    chain: "ethereum"
    protocol_type: "vault"
    vulnerability_type: "misconfiguration"
    root_cause: "Misconfigured Aave v1 token led to wrong collateral calc"
    attack_vector: |
      1. Deposit into vault with misconfigured aToken
      2. Inflated share calculation
      3. Withdraw more than deposited
    lessons:
      - "Configuration errors are vulnerabilities"
      - "Test all integration paths"
    tags: ["vault", "configuration", "aave"]

  - id: "2023-006"
    name: "Level Finance"
    date: "2023-05-01"
    amount_lost: 1100000
    chain: "bsc"
    protocol_type: "perp"
    vulnerability_type: "business_logic"
    root_cause: "Referral rewards could be claimed multiple times"
    attack_vector: |
      1. Create referral relationship
      2. Claim referral rewards
      3. Bug in epoch logic allowed re-claiming
    vulnerable_pattern: |
      function claimReward(uint256 epoch) external {
          require(!claimed[msg.sender][epoch], "Already claimed");
          // But epoch could be manipulated to bypass check
          claimed[msg.sender][epoch] = true;
          _transfer(msg.sender, rewards[epoch]);
      }
    lessons:
      - "Reward claiming needs careful epoch handling"
      - "Test multiple claims in same epoch"
    tags: ["rewards", "referral", "epoch", "double_claim"]

  - id: "2023-007"
    name: "Sturdy Finance"
    date: "2023-06-12"
    amount_lost: 800000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "read_only_reentrancy"
    root_cause: "Price oracle read during Balancer callback returned wrong value"
    attack_vector: |
      1. Flash loan from Balancer
      2. During callback, Sturdy reads getRate()
      3. Rate is stale/manipulated during loan
      4. Borrow against wrong collateral value
    vulnerable_pattern: |
      function getCollateralPrice() external view returns (uint256) {
          return balancerPool.getRate();  // Manipulable during flash loan!
      }
    lessons:
      - "Read-only reentrancy through view functions"
      - "Balancer getRate() is unsafe during flash loans"
    tags: ["lending", "balancer", "read_only_reentrancy", "oracle"]

  - id: "2023-008"
    name: "Hundred Finance"
    date: "2023-04-15"
    amount_lost: 7400000
    chain: "optimism"
    protocol_type: "lending"
    vulnerability_type: "first_depositor"
    root_cause: "Empty market share manipulation"
    attack_vector: |
      1. Be first depositor with dust amount
      2. Donate large amount to inflate share price
      3. Other depositors get 0 shares due to rounding
      4. Steal their deposits
    vulnerable_pattern: |
      function deposit(uint256 amount) external {
          uint256 shares = totalShares == 0
              ? amount
              : amount * totalShares / totalAssets;  // Rounds to 0!
          // ... mint shares
      }
    fix_applied: "Add minimum share requirement, virtual offset"
    lessons:
      - "First depositor attack is common in vaults"
      - "Use virtual offset or minimum shares"
      - "OpenZeppelin ERC4626 has mitigations"
    tags: ["lending", "vault", "first_depositor", "rounding", "donation"]

  - id: "2023-009"
    name: "Platypus Finance"
    date: "2023-02-16"
    amount_lost: 8500000
    chain: "avalanche"
    protocol_type: "stablecoin"
    vulnerability_type: "flash_loan"
    root_cause: "Borrow check used stale collateral value"
    attack_vector: |
      1. Flash loan USDC
      2. Deposit as collateral
      3. emergencyWithdraw in same tx (no solvency check)
      4. Keep borrowed USP, repay flash loan
    vulnerable_pattern: |
      function emergencyWithdraw() external {
          // Missing solvency check!
          _withdraw(msg.sender, balances[msg.sender]);
      }
    lessons:
      - "Emergency functions still need safety checks"
      - "Flash loan in same tx as borrow = danger"
    tags: ["stablecoin", "flash_loan", "emergency", "solvency"]

  - id: "2023-010"
    name: "dForce"
    date: "2023-02-10"
    amount_lost: 3650000
    chain: "arbitrum"
    protocol_type: "lending"
    vulnerability_type: "reentrancy"
    root_cause: "Reentrancy via wstETH callback"
    attack_vector: |
      1. Deposit wstETH
      2. wstETH triggers callback on transfer
      3. Reenter during callback to borrow before deposit registered
    lessons:
      - "All token transfers can have callbacks"
      - "Even standard-looking tokens may have hooks"
    tags: ["lending", "reentrancy", "wsteth", "callback"]

  - id: "2023-011"
    name: "Orion Protocol"
    date: "2023-02-02"
    amount_lost: 3000000
    chain: "ethereum"
    protocol_type: "dex"
    vulnerability_type: "reentrancy"
    root_cause: "Reentrancy in depositAsset via token callback"
    attack_vector: |
      1. Create malicious token with transfer hook
      2. Deposit triggers hook
      3. Reenter to manipulate balances
    vulnerable_pattern: |
      function depositAsset(address token, uint256 amount) external {
          IERC20(token).transferFrom(msg.sender, address(this), amount);
          // State update after external call
          balances[msg.sender][token] += amount;
      }
    lessons:
      - "Malicious tokens are an attack vector"
      - "Don't accept arbitrary tokens without protection"
    tags: ["dex", "reentrancy", "malicious_token"]

  - id: "2023-012"
    name: "Mango Markets"
    date: "2022-10-11"
    amount_lost: 116000000
    chain: "solana"
    protocol_type: "perp"
    vulnerability_type: "oracle_manipulation"
    root_cause: "Self-referential oracle allowed price manipulation"
    attack_vector: |
      1. Take large MNGO-PERP position
      2. Buy MNGO spot on illiquid markets
      3. Oracle updates to high price
      4. Borrow against inflated position
      5. Withdraw all protocol funds
    lessons:
      - "Perp oracle can't use own trading price"
      - "Illiquid markets = manipulable oracles"
      - "This was a controversial 'exploit vs attack' case"
    tags: ["perp", "oracle", "solana", "illiquid", "manipulation"]

exploits_2022_extended:
  - id: "2022-005"
    name: "Wintermute"
    date: "2022-09-20"
    amount_lost: 160000000
    chain: "ethereum"
    protocol_type: "market_maker"
    vulnerability_type: "key_compromise"
    root_cause: "Vanity address generated with vulnerable Profanity tool"
    attack_vector: |
      1. Profanity tool had weak random number generation
      2. Attacker brute-forced private key from vanity address
      3. Drained hot wallet
    lessons:
      - "Don't use vanity address generators for hot wallets"
      - "Entropy source is critical"
      - "Cold storage for large amounts"
    tags: ["key_compromise", "vanity_address", "profanity", "rng"]

  - id: "2022-006"
    name: "Inverse Finance (1st)"
    date: "2022-04-02"
    amount_lost: 15600000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "oracle_manipulation"
    root_cause: "Used SushiSwap LP price, manipulated via flash loan"
    attack_vector: |
      1. Flash loan large ETH amount
      2. Swap to INV on SushiSwap (crash price)
      3. Borrow DOLA against cheap INV collateral
      4. Swap back, repay flash loan
    lessons:
      - "DEX LP tokens are manipulable oracles"
      - "Never use AMM for lending oracle"
    tags: ["lending", "oracle", "sushiswap", "flash_loan"]

  - id: "2022-007"
    name: "Fei Protocol (Rari)"
    date: "2022-04-30"
    amount_lost: 80000000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "reentrancy"
    root_cause: "Classic reentrancy in Compound fork"
    attack_vector: |
      1. Borrow from pool
      2. Token transfer triggers callback
      3. Reenter to borrow more before first borrow recorded
    lessons:
      - "Compound forks often miss reentrancy guards"
      - "exitMarket needs protection too"
    tags: ["lending", "compound", "fork", "reentrancy"]

  - id: "2022-008"
    name: "Harmony Horizon Bridge"
    date: "2022-06-23"
    amount_lost: 100000000
    chain: "harmony"
    protocol_type: "bridge"
    vulnerability_type: "key_compromise"
    root_cause: "2 of 5 multisig compromised"
    attack_vector: |
      1. Attacker compromised 2 validator keys
      2. 2/5 threshold meant only 2 needed
      3. Signed fraudulent withdrawals
    lessons:
      - "2/5 multisig is NOT secure"
      - "Higher thresholds (4/7, 5/9) needed"
    tags: ["bridge", "multisig", "key_compromise", "threshold"]

  - id: "2022-009"
    name: "Qubit Finance"
    date: "2022-01-28"
    amount_lost: 80000000
    chain: "bsc"
    protocol_type: "lending"
    vulnerability_type: "access_control"
    root_cause: "deposit() accepted ETH address as token, minted xETH"
    attack_vector: |
      1. Call deposit() with tokenAddress = 0x0 (ETH)
      2. No validation that value was sent
      3. Got credited xETH for free
      4. Borrow against fake collateral
    vulnerable_pattern: |
      function deposit(address token, uint256 amount) external {
          if (token == ETH_ADDRESS) {
              // Should check msg.value == amount!
          }
          qToken[token].mint(msg.sender, amount);
      }
    lessons:
      - "ETH handling needs extra validation"
      - "Require msg.value == amount for ETH deposits"
    tags: ["lending", "validation", "eth", "bsc"]

  - id: "2022-010"
    name: "Multichain (AnySwap)"
    date: "2022-01-18"
    amount_lost: 3000000
    chain: "multiple"
    protocol_type: "bridge"
    vulnerability_type: "signature_replay"
    root_cause: "Permit signatures could be replayed across chains"
    attack_vector: |
      1. Collect permit signatures from one chain
      2. Replay on other chains where same address exists
      3. Drain approved tokens
    lessons:
      - "Always include chainId in signatures"
      - "EIP-712 domain separator is critical"
    tags: ["bridge", "signature", "replay", "permit", "chain_id"]

  - id: "2022-011"
    name: "Cashio"
    date: "2022-03-23"
    amount_lost: 52000000
    chain: "solana"
    protocol_type: "stablecoin"
    vulnerability_type: "access_control"
    root_cause: "Account validation missing, fake collateral accepted"
    attack_vector: |
      1. Create fake collateral account
      2. Missing check that collateral was real LP tokens
      3. Mint CASH stablecoin against fake collateral
    vulnerable_pattern: |
      // Rust/Anchor - missing constraint
      #[account]
      pub collateral: AccountInfo<'info>,  // Should be: Account<'info, Collateral>
    lessons:
      - "Solana: Always validate account types"
      - "Use Anchor's typed accounts"
    tags: ["solana", "stablecoin", "account_validation", "anchor"]

  - id: "2022-012"
    name: "Cream Finance (1st)"
    date: "2021-08-30"
    amount_lost: 18800000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "flash_loan"
    root_cause: "AMP token reentrancy not handled"
    attack_vector: |
      1. Flash loan AMP tokens
      2. AMP has transfer hook (ERC-777 like)
      3. Reenter during transfer to borrow before collateral check
    lessons:
      - "ERC-777 and similar tokens enable reentrancy"
      - "Cream was exploited 3 times!"
    tags: ["lending", "reentrancy", "amp", "erc777"]

exploits_2021:
  - id: "2021-002"
    name: "Poly Network"
    date: "2021-08-10"
    amount_lost: 611000000
    chain: "multiple"
    protocol_type: "bridge"
    vulnerability_type: "access_control"
    root_cause: "Could change keeper to attacker-controlled address"
    attack_vector: |
      1. Call verifyHeaderAndExecuteTx with crafted message
      2. Message called putCurEpochConPubKeyBytes
      3. This changed the keeper to attacker
      4. Attacker became keeper, could sign any withdrawal
    lessons:
      - "Access control over keeper/admin changes"
      - "$611M largest DeFi hack (funds returned)"
    tags: ["bridge", "access_control", "keeper", "cross_chain"]

  - id: "2021-003"
    name: "Compound (Proposal 62)"
    date: "2021-09-30"
    amount_lost: 80000000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "business_logic"
    root_cause: "Governance proposal had bug, distributed excess COMP"
    attack_vector: |
      1. Proposal 62 updated COMP distribution
      2. Bug in accrueComp caused over-distribution
      3. Users claimed more COMP than entitled
    lessons:
      - "Test governance proposals extensively"
      - "Gradual rollout of distribution changes"
    tags: ["governance", "compound", "distribution", "bug"]

  - id: "2021-004"
    name: "Badger DAO"
    date: "2021-12-02"
    amount_lost: 120000000
    chain: "ethereum"
    protocol_type: "vault"
    vulnerability_type: "frontend_attack"
    root_cause: "Cloudflare API key compromised, malicious approvals injected"
    attack_vector: |
      1. Attacker got Cloudflare API key
      2. Injected malicious script into frontend
      3. Script prompted users to approve attacker
      4. Attacker drained approved tokens
    lessons:
      - "Frontend security is critical"
      - "API key rotation and monitoring"
      - "Not a smart contract bug but devastating"
    tags: ["vault", "frontend", "phishing", "approval"]

  - id: "2021-005"
    name: "Indexed Finance"
    date: "2021-10-15"
    amount_lost: 16000000
    chain: "ethereum"
    protocol_type: "index"
    vulnerability_type: "price_manipulation"
    root_cause: "Reindexing logic could be manipulated"
    attack_vector: |
      1. Add very low-cap token to index
      2. Manipulate its price during reindex
      3. Extract value from index holders
    lessons:
      - "Index rebalancing is sensitive"
      - "Price checks during rebalance"
    tags: ["index", "rebalance", "manipulation"]

  - id: "2021-006"
    name: "Uranium Finance"
    date: "2021-04-28"
    amount_lost: 50000000
    chain: "bsc"
    protocol_type: "amm"
    vulnerability_type: "arithmetic"
    root_cause: "Balance calculation had wrong multiplier (100 vs 10000)"
    attack_vector: |
      1. Simple arithmetic error in swap
      2. Could swap 1 token for 100x output
    vulnerable_pattern: |
      // Wrong: used 10000 instead of 100
      require(balance0 * balance1 * 10000 >= reserve0 * reserve1 * 100);
      // Should be: 100 on both sides
    lessons:
      - "Magic numbers are dangerous"
      - "Use named constants"
      - "Extensive swap fuzzing"
    tags: ["amm", "arithmetic", "bsc", "constant"]

exploits_2020:
  - id: "2020-003"
    name: "Harvest Finance"
    date: "2020-10-26"
    amount_lost: 34000000
    chain: "ethereum"
    protocol_type: "vault"
    vulnerability_type: "flash_loan"
    root_cause: "Vault used Curve spot price, manipulated via flash loan"
    attack_vector: |
      1. Flash loan USDT/USDC
      2. Swap to manipulate Curve pool
      3. Deposit to Harvest at inflated rate
      4. Swap back to restore price
      5. Withdraw at profit
    lessons:
      - "Classic flash loan price manipulation"
      - "Use TWAP for vault valuations"
    tags: ["vault", "flash_loan", "curve", "oracle"]

  - id: "2020-004"
    name: "Akropolis"
    date: "2020-11-12"
    amount_lost: 2000000
    chain: "ethereum"
    protocol_type: "vault"
    vulnerability_type: "reentrancy"
    root_cause: "deposit() with malicious token enabled reentrancy"
    attack_vector: |
      1. Create fake token with transfer hook
      2. Deposit fake token
      3. In hook, call deposit again with real token
      4. Share calculation manipulated
    lessons:
      - "Reentrancy with malicious tokens"
      - "Whitelist tokens or use reentrancy guard"
    tags: ["vault", "reentrancy", "malicious_token"]

  - id: "2020-005"
    name: "Value DeFi"
    date: "2020-11-14"
    amount_lost: 7000000
    chain: "ethereum"
    protocol_type: "vault"
    vulnerability_type: "flash_loan"
    root_cause: "Oracle manipulation during flash loan"
    attack_vector: |
      1. Flash loan from Aave
      2. Manipulate Curve pool price
      3. Withdraw from Value vault at better rate
    lessons:
      - "Complex flash loan arbitrage"
      - "Multiple protocols in attack path"
    tags: ["vault", "flash_loan", "aave", "curve"]

  - id: "2020-006"
    name: "Pickle Finance"
    date: "2020-11-21"
    amount_lost: 20000000
    chain: "ethereum"
    protocol_type: "vault"
    vulnerability_type: "access_control"
    root_cause: "Jar (vault) swap function could be called by anyone"
    attack_vector: |
      1. Call swapExactJarForJar with evil jar
      2. Evil jar's freeWithdraw sent funds to attacker
      3. Legitimate jar funds drained
    vulnerable_pattern: |
      function swapExactJarForJar(
          address _fromJar,
          address _toJar,  // Attacker controls this!
          uint256 _amount
      ) external {
          // No check that _toJar is legitimate
          IJar(_fromJar).withdraw(_amount);
          IJar(_toJar).deposit(_amount);  // Evil jar!
      }
    lessons:
      - "Validate all external contract addresses"
      - "Whitelist allowed jars/vaults"
    tags: ["vault", "access_control", "jar", "whitelist"]

# Pattern Signatures for Detection
pattern_signatures:
  critical_patterns:
    - name: "Unprotected External Call Target"
      regex: '(call|delegatecall)\([^)]*\)\s*\([^)]*\)'
      description: "User-controlled call target"
      severity: "CRITICAL"

    - name: "Missing Reentrancy Guard on Value Transfer"
      regex: '(transfer|call\{value|send)\([^)]*\)(?!.*nonReentrant)'
      description: "Value transfer without reentrancy protection"
      severity: "HIGH"

    - name: "tx.origin Authentication"
      regex: 'require\s*\(\s*tx\.origin'
      description: "Using tx.origin for access control"
      severity: "HIGH"

    - name: "Unprotected Initializer"
      regex: 'function\s+initialize\s*\([^)]*\)\s*(external|public)(?!.*initializer)'
      description: "Initialize without modifier"
      severity: "CRITICAL"

    - name: "Spot Price for Valuation"
      regex: '(getReserves|balanceOf.*\/.*totalSupply)'
      description: "Using spot price for value calculation"
      severity: "HIGH"

    - name: "Unchecked Low Level Call"
      regex: '\.call\([^)]*\)\s*;(?!\s*(require|if))'
      description: "Low level call without return check"
      severity: "MEDIUM"

  medium_patterns:
    - name: "Division Before Multiplication"
      regex: '\s*\/\s*\d+\s*\*'
      description: "Precision loss from operation order"
      severity: "MEDIUM"

    - name: "Block Timestamp Dependence"
      regex: 'block\.timestamp\s*[<>=]'
      description: "Logic depends on block.timestamp"
      severity: "LOW"

    - name: "Hardcoded Address"
      regex: '0x[a-fA-F0-9]{40}'
      description: "Hardcoded address (check if intentional)"
      severity: "INFO"

# Attack Templates
attack_templates:
  flash_loan_oracle:
    name: "Flash Loan Oracle Manipulation"
    steps:
      - "Flash loan large amount from Aave/dYdX/Balancer"
      - "Swap to manipulate target AMM reserves"
      - "Perform action (borrow/deposit/withdraw) at manipulated price"
      - "Swap back to restore price"
      - "Repay flash loan, keep profit"
    requirements:
      - "Protocol uses spot price from AMM"
      - "No TWAP or Chainlink oracle"
      - "Sufficient AMM liquidity to manipulate"
    potential_profit: "Varies, typically 1-10% of affected pool"

  reentrancy_classic:
    name: "Classic Reentrancy"
    steps:
      - "Call vulnerable withdraw/claim function"
      - "Receive ETH/token in fallback"
      - "Re-call withdraw before balance updated"
      - "Repeat until drained"
    requirements:
      - "External call before state update"
      - "No reentrancy guard"
      - "Sufficient contract balance"

  first_depositor:
    name: "First Depositor Attack"
    steps:
      - "Be first to deposit 1 wei"
      - "Donate large amount directly to vault"
      - "Share price now inflated"
      - "Victim deposits, gets 0 shares due to rounding"
      - "Withdraw victim's deposit"
    requirements:
      - "Empty vault/pool"
      - "No minimum deposit/shares"
      - "Uses division for share calculation"
    potential_profit: "100% of subsequent deposits"

  governance_flash_loan:
    name: "Flash Loan Governance Attack"
    steps:
      - "Flash loan governance tokens"
      - "Create and vote on malicious proposal"
      - "If instant execution, proposal runs"
      - "Drain treasury or change admin"
    requirements:
      - "No snapshot mechanism"
      - "Instant or fast proposal execution"
      - "Voting power = current balance"
    potential_profit: "Entire protocol treasury"

# Statistics
stats:
  total_exploits: 55
  total_value_lost_usd: 4200000000
  by_year:
    2024: 6
    2023: 12
    2022: 12
    2021: 6
    2020: 6
  by_category:
    oracle_manipulation: 12
    reentrancy: 10
    access_control: 9
    flash_loan: 8
    bridge_compromise: 6
    business_logic: 5
    key_compromise: 3
    arithmetic: 2
  most_exploited_protocol_types:
    - lending: 18
    - bridge: 8
    - vault: 8
    - amm: 4
    - stablecoin: 3
