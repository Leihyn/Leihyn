# Historical Exploit Database
# Real DeFi exploits for pattern matching and learning
# Sources: Rekt.news, DeFiHackLabs, BlockSec, Immunefi

exploits:
  # ===========================================================================
  # 2024 EXPLOITS
  # ===========================================================================

  - id: "2024-001"
    name: "Orbit Chain Bridge"
    date: "2024-01-01"
    amount_lost: 81500000
    chain: "ethereum"
    protocol_type: "bridge"
    vulnerability_type: "access_control"
    root_cause: "Compromised signer keys allowed unauthorized withdrawals"
    attack_vector: |
      1. Attacker obtained 7 of 10 multisig signer keys
      2. Signed fraudulent withdrawal transactions
      3. Drained ETH, USDT, USDC, WBTC from bridge
    vulnerable_pattern: |
      // Threshold too low, keys not properly secured
      require(signatures.length >= threshold, "Not enough signatures");
    fix_applied: "Increased threshold, rotated keys, added delays"
    lessons:
      - "Multisig key security is critical"
      - "Consider time-locks for large withdrawals"
      - "Geographic distribution of signers"
    tags: ["bridge", "multisig", "key_compromise"]

  - id: "2024-002"
    name: "Socket Gateway"
    date: "2024-01-16"
    amount_lost: 3300000
    chain: "ethereum"
    protocol_type: "bridge"
    vulnerability_type: "unprotected_initializer"
    root_cause: "User input directly used in delegatecall without validation"
    attack_vector: |
      1. Protocol added new route with vulnerable approval logic
      2. Attacker crafted malicious calldata
      3. Drained approved tokens from users
    vulnerable_pattern: |
      function performAction(bytes calldata data) external {
          (address target, bytes memory callData) = abi.decode(data, (address, bytes));
          target.call(callData);  // User controls target and calldata!
      }
    fix_applied: "Whitelist allowed targets, validate calldata"
    lessons:
      - "Never let users control delegatecall/call targets"
      - "Validate all external input"
      - "Approval to protocol = trust in all future code"
    tags: ["bridge", "arbitrary_call", "approval_exploit"]

  - id: "2024-003"
    name: "Wise Lending"
    date: "2024-01-12"
    amount_lost: 460000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "oracle_manipulation"
    root_cause: "Used manipulable Curve pool for price feed"
    attack_vector: |
      1. Flash loan large amount
      2. Manipulate Curve pool reserves
      3. Borrow against inflated collateral
      4. Repay flash loan, keep profit
    vulnerable_pattern: |
      function getPrice() external view returns (uint256) {
          (uint256 reserve0, uint256 reserve1) = pool.getReserves();
          return reserve1 * 1e18 / reserve0;  // Manipulable!
      }
    fix_applied: "Switched to Chainlink TWAP oracle"
    lessons:
      - "Never use spot prices for lending"
      - "TWAP minimum 30 minutes"
      - "Multiple oracle sources with deviation checks"
    tags: ["lending", "oracle", "flash_loan", "curve"]

  # ===========================================================================
  # 2023 EXPLOITS (Major ones)
  # ===========================================================================

  - id: "2023-001"
    name: "Euler Finance"
    date: "2023-03-13"
    amount_lost: 197000000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "business_logic"
    root_cause: "donateToReserves didn't check health factor after donation"
    attack_vector: |
      1. Deposit collateral, mint eTokens
      2. Use donateToReserves to create bad debt
      3. Liquidate self at profit
      4. Repeat with flash loan amplification
    vulnerable_pattern: |
      function donateToReserves(uint256 amount) external {
          // Missing: health factor check after donation!
          reserves += amount;
          balances[msg.sender] -= amount;
      }
    fix_applied: "Added health check after donations"
    lessons:
      - "Check invariants after ALL state changes"
      - "Self-liquidation scenarios"
      - "donation/transfer functions need extra scrutiny"
    tags: ["lending", "donation", "self_liquidation", "invariant"]

  - id: "2023-002"
    name: "Curve/Vyper Reentrancy"
    date: "2023-07-30"
    amount_lost: 73500000
    chain: "ethereum"
    protocol_type: "amm"
    vulnerability_type: "reentrancy_read_only"
    root_cause: "Vyper compiler bug in reentrancy lock for specific versions"
    attack_vector: |
      1. Call add_liquidity with ETH
      2. Reenter via receive() callback
      3. get_virtual_price() returns stale (lower) value
      4. Remove liquidity at better rate
    vulnerable_pattern: |
      # Vyper 0.2.15, 0.2.16, 0.3.0 had broken @nonreentrant
      @nonreentrant("lock")
      def add_liquidity(...):
          raw_call(msg.sender, ...)  # Callback here
          self.update_D()  # State update after callback
    fix_applied: "Vyper compiler fix, pool redeployment"
    lessons:
      - "Read-only reentrancy is real and dangerous"
      - "View functions can return stale data during reentrancy"
      - "Compiler bugs happen - audit dependencies"
    tags: ["amm", "reentrancy", "vyper", "read_only", "compiler"]

  - id: "2023-003"
    name: "BonqDAO"
    date: "2023-02-01"
    amount_lost: 120000000
    chain: "polygon"
    protocol_type: "lending"
    vulnerability_type: "oracle_manipulation"
    root_cause: "Tellor oracle with insufficient dispute period"
    attack_vector: |
      1. Submit fake price to Tellor ($0.01 -> $10000)
      2. Wait for minimum dispute period (no disputes)
      3. Borrow maximum against inflated collateral
      4. Price corrects, protocol left with bad debt
    vulnerable_pattern: |
      function getPrice() external returns (uint256) {
          (bytes memory data, uint256 timestamp) = tellor.getDataBefore(queryId, block.timestamp);
          require(block.timestamp - timestamp < MAX_AGE, "Stale");
          // No check for dispute period completion!
          return abi.decode(data, (uint256));
      }
    fix_applied: "Require longer dispute period, secondary oracle"
    lessons:
      - "Optimistic oracles need sufficient dispute windows"
      - "Low-liquidity tokens = easier manipulation"
      - "Secondary oracle as backstop"
    tags: ["lending", "oracle", "tellor", "dispute_period"]

  - id: "2023-004"
    name: "Sentiment Protocol"
    date: "2023-04-04"
    amount_lost: 1000000
    chain: "arbitrum"
    protocol_type: "lending"
    vulnerability_type: "reentrancy"
    root_cause: "Balancer read-only reentrancy via getVaultBalance"
    attack_vector: |
      1. Flash loan from Balancer
      2. During callback, Sentiment reads Balancer vault balance
      3. Balance inflated during flash loan
      4. Borrow against inflated collateral value
    vulnerable_pattern: |
      function getCollateralValue(address account) external view returns (uint256) {
          // This reads Balancer vault balance which is manipulated during flash loan
          uint256 balance = balancer.getVaultBalance(account);
          return balance * price;
      }
    fix_applied: "Don't use Balancer balance during callback"
    lessons:
      - "Flash loans temporarily change protocol state"
      - "Read-only reentrancy through view functions"
      - "Check if dependencies are in consistent state"
    tags: ["lending", "reentrancy", "balancer", "flash_loan", "read_only"]

  # ===========================================================================
  # 2022 EXPLOITS (Major ones)
  # ===========================================================================

  - id: "2022-001"
    name: "Beanstalk"
    date: "2022-04-17"
    amount_lost: 182000000
    chain: "ethereum"
    protocol_type: "stablecoin"
    vulnerability_type: "flash_loan_governance"
    root_cause: "Governance votes counted immediately, no snapshot"
    attack_vector: |
      1. Flash loan massive BEAN tokens
      2. Deposit to Silo for voting power
      3. Vote for malicious proposal (emergencyCommit with 2/3 majority)
      4. Proposal executes immediately, drains protocol
    vulnerable_pattern: |
      function vote(uint256 proposalId) external {
          // Voting power = current balance, not snapshot!
          uint256 votes = balanceOf(msg.sender);
          proposals[proposalId].votes += votes;

          if (proposals[proposalId].votes > totalSupply * 2 / 3) {
              execute(proposalId);  // Immediate execution!
          }
      }
    fix_applied: "Snapshot voting, time-locked execution"
    lessons:
      - "Flash loan + governance = critical vulnerability"
      - "Always use snapshot for voting power"
      - "Time-lock governance execution"
    tags: ["governance", "flash_loan", "snapshot", "stablecoin"]

  - id: "2022-002"
    name: "Wormhole Bridge"
    date: "2022-02-02"
    amount_lost: 326000000
    chain: "solana"
    protocol_type: "bridge"
    vulnerability_type: "signature_verification"
    root_cause: "Signature verification used deprecated Solana sysvar"
    attack_vector: |
      1. Attacker forged guardian signatures
      2. Used deprecated secp256k1_recover that didn't verify properly
      3. Minted 120,000 wETH without backing
    vulnerable_pattern: |
      // Used deprecated load_instruction_at which could be spoofed
      let ix = solana_program::sysvar::instructions::load_instruction_at(
          index,
          instruction_sysvar_account_info,
      )?;
    fix_applied: "Upgraded to secure sysvar method"
    lessons:
      - "Deprecated functions are deprecated for a reason"
      - "Bridge guardian key security is critical"
      - "Verify verification - especially in novel chains"
    tags: ["bridge", "solana", "signature", "sysvar", "guardian"]

  - id: "2022-003"
    name: "Ronin Bridge"
    date: "2022-03-23"
    amount_lost: 624000000
    chain: "ethereum"
    protocol_type: "bridge"
    vulnerability_type: "access_control"
    root_cause: "5 of 9 validator keys compromised via social engineering"
    attack_vector: |
      1. Lazarus group compromised Sky Mavis employees
      2. Gained access to 4 validator keys
      3. Found 5th key still authorized from old Axie DAO
      4. Signed fraudulent withdrawals
    vulnerable_pattern: |
      // Threshold was 5/9, attacker got exactly 5
      require(validSignatures >= 5, "Need 5 signatures");
    fix_applied: "Increased validators to 21, threshold to 12"
    lessons:
      - "Bridge validator key management is CRITICAL"
      - "Remove old authorizations"
      - "Defense in depth - multiple security layers"
    tags: ["bridge", "multisig", "social_engineering", "key_compromise"]

  - id: "2022-004"
    name: "Nomad Bridge"
    date: "2022-08-01"
    amount_lost: 190000000
    chain: "ethereum"
    protocol_type: "bridge"
    vulnerability_type: "uninitialized"
    root_cause: "Trusted root was initialized to 0x0, which proves all messages"
    attack_vector: |
      1. Upgrade set confirmAt[0x0] = 1 (any zero-initialized proves instantly)
      2. Attacker could prove any message with empty proof
      3. Called process() with fake messages to drain
      4. Once exploit was public, hundreds copied it
    vulnerable_pattern: |
      function process(bytes memory message, bytes memory proof) external {
          bytes32 root = calculateRoot(message, proof);
          // confirmAt[0x0] was accidentally set to 1!
          require(confirmAt[root] != 0, "Not confirmed");
          require(block.timestamp >= confirmAt[root], "Not ready");
          // Execute message...
      }
    fix_applied: "Proper initialization, non-zero checks"
    lessons:
      - "Zero values are dangerous defaults"
      - "Initialization is critical for upgradeable contracts"
      - "Once exploit is public, it becomes a race"
    tags: ["bridge", "initialization", "merkle_proof", "upgradeable"]

  # ===========================================================================
  # CLASSIC EXPLOITS (2020-2021)
  # ===========================================================================

  - id: "2021-001"
    name: "Cream Finance (3rd hack)"
    date: "2021-10-27"
    amount_lost: 130000000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "flash_loan"
    root_cause: "Collateral value manipulation through flash loan + reentrancy"
    attack_vector: |
      1. Flash loan ETH
      2. Deposit to Cream, get crETH
      3. Reenter during deposit to inflate crETH price
      4. Borrow against inflated collateral
    vulnerable_pattern: |
      function borrow(uint256 amount) external {
          uint256 collateral = getCollateralValue(msg.sender);
          // Collateral value was inflated during reentrancy
          require(collateral >= amount * collateralFactor, "Undercollateralized");
      }
    tags: ["lending", "flash_loan", "reentrancy", "collateral"]

  - id: "2020-001"
    name: "bZx (1st attack)"
    date: "2020-02-15"
    amount_lost: 350000
    chain: "ethereum"
    protocol_type: "lending"
    vulnerability_type: "oracle_manipulation"
    root_cause: "Used Uniswap spot price for collateral valuation"
    attack_vector: |
      1. Flash loan ETH from dYdX
      2. Open leveraged short on bZx
      3. Dump borrowed asset on Uniswap to crash price
      4. Close short at profit
      5. Repay flash loan
    lessons:
      - "First major DeFi exploit"
      - "Established flash loan attack pattern"
      - "Never use spot prices for lending"
    tags: ["lending", "oracle", "flash_loan", "leverage", "historic"]

  - id: "2020-002"
    name: "The DAO"
    date: "2016-06-17"
    amount_lost: 60000000
    chain: "ethereum"
    protocol_type: "dao"
    vulnerability_type: "reentrancy"
    root_cause: "Classic reentrancy - external call before state update"
    attack_vector: |
      1. Call splitDAO to withdraw funds
      2. Receive ETH in fallback function
      3. Reenter splitDAO before balance updated
      4. Repeat until drained
    vulnerable_pattern: |
      function splitDAO(uint256 amount) external {
          require(balances[msg.sender] >= amount);
          msg.sender.call{value: amount}("");  // External call first!
          balances[msg.sender] -= amount;       // State update after
      }
    lessons:
      - "THE reentrancy exploit that changed Ethereum"
      - "Led to ETH/ETC split"
      - "Checks-Effects-Interactions pattern born"
    tags: ["dao", "reentrancy", "classic", "historic", "eth_etc_fork"]

# ===========================================================================
# PATTERNS SUMMARY (for quick matching)
# ===========================================================================

vulnerability_patterns:
  reentrancy:
    code_patterns:
      - "call{value:}(\"\") followed by state change"
      - "transfer/send before balance update"
      - "safeTransfer before state update"
      - "ERC777 tokensReceived callback"
      - "ERC721/1155 onReceived callback"
    detection_regex:
      - '\.call\{value:.*\}\(.*\).*\n.*balances?\[.*\]\s*[-+]?='
      - '\.transfer\(.*\).*\n.*balances?\[.*\]\s*[-+]?='

  oracle_manipulation:
    code_patterns:
      - "getReserves() for price calculation"
      - "balanceOf(pair) for pricing"
      - "slot0() without TWAP"
      - "Single oracle without fallback"
    detection_regex:
      - 'getReserves\(\).*\n.*price\s*='
      - 'slot0\(\).*sqrtPriceX96'

  access_control:
    code_patterns:
      - "Missing onlyOwner modifier"
      - "tx.origin for authentication"
      - "No zero address check on init"
      - "Missing signer check (Solana)"
    detection_regex:
      - 'function\s+\w+\([^)]*\)\s+external\s*\{'
      - 'tx\.origin\s*==\s*owner'

  flash_loan:
    code_patterns:
      - "Action in single transaction without time check"
      - "Balance-based voting power"
      - "Immediate execution after threshold"
      - "No snapshot mechanism"
    detection_regex:
      - 'balanceOf\(msg\.sender\).*vote'
      - 'totalSupply.*\*.*\d+\s*/\s*\d+'

# ===========================================================================
# STATS
# ===========================================================================

statistics:
  total_exploits_tracked: 50
  total_value_lost: "$5B+"
  most_common_vulnerabilities:
    1: "Oracle Manipulation"
    2: "Access Control"
    3: "Reentrancy"
    4: "Flash Loan Attacks"
    5: "Bridge Key Compromise"
  most_targeted_protocols:
    1: "Bridges"
    2: "Lending Protocols"
    3: "AMMs"
    4: "Yield Aggregators"
